# frozen_string_literal: true

require 'fileutils'
require 'json'
require_relative '../../core/logger'
require_relative 'react_component_generator'

module RjuiTools
  module React
    module Generators
      class ConverterGenerator
        def initialize(name, options = {}, config = {}, command_line = nil)
          @name = name  # PascalCase name like CodeBlock
          @class_name = "#{name}Converter"
          @options = options
          @config = config
          @command_line = command_line
          @logger = Core::Logger
        end

        def generate
          @logger.info "Generating custom converter: #{@class_name}"

          # Create converter file
          create_converter_file

          # Update mappings file
          update_mappings_file

          # Create React component skeleton
          component_generator = ReactComponentGenerator.new(@name, @options, @config, @command_line)
          component_generator.generate

          # Generate attribute definition file for validation
          generate_attribute_definition_file

          @logger.success "Successfully generated converter: #{@class_name}"
          @logger.info "Converter file: #{converter_file_path}"
          @logger.info "Run 'rjui build' to use the new component in your layouts"
        end

        private

        def extensions_dir
          # Check if we're in the project with rjui_tools at root
          if File.exist?(File.join(Dir.pwd, 'rjui_tools'))
            File.join(Dir.pwd, 'rjui_tools', 'lib', 'react', 'converters', 'extensions')
          else
            File.join(Dir.pwd, 'lib', 'react', 'converters', 'extensions')
          end
        end

        def converter_file_path
          snake_case_name = to_snake_case(@name)
          File.join(extensions_dir, "#{snake_case_name}_converter.rb")
        end

        def create_converter_file
          FileUtils.mkdir_p(extensions_dir)

          file_path = converter_file_path

          if File.exist?(file_path)
            @logger.warn "Converter file already exists: #{file_path}"
            print "Overwrite? (y/n): "
            response = $stdin.gets.chomp.downcase
            return unless response == 'y'
          end

          File.write(file_path, converter_template)
          @logger.info "Created converter file: #{file_path}"
        end

        def update_mappings_file
          mappings_file = File.join(extensions_dir, 'converter_mappings.rb')

          if !File.exist?(mappings_file)
            create_initial_mappings_file(mappings_file)
            return
          end

          content = File.read(mappings_file)

          # Check if mapping already exists
          if content.include?("'#{@name}' =>")
            @logger.warn "Mapping for '#{@name}' already exists in converter_mappings.rb"
            return
          end

          # Add new mapping
          new_mapping = "          '#{@name}' => '#{@class_name}',"

          # Insert the new mapping before the closing brace
          content.sub!(/(CONVERTER_MAPPINGS = \{.*?)(,?)(\s*)(        \}\.freeze)/m) do
            existing = $1
            closing = $4

            if existing =~ /=>/
              "#{existing},\n#{new_mapping}\n#{closing}"
            else
              "#{existing}\n#{new_mapping}\n#{closing}"
            end
          end

          File.write(mappings_file, content)
          @logger.info "Updated converter_mappings.rb"
        end

        def create_initial_mappings_file(mappings_file)
          FileUtils.mkdir_p(File.dirname(mappings_file))

          content = <<~RUBY
            # frozen_string_literal: true

            # This file maps custom component types to their converter classes
            # Auto-generated by rjui g converter command

            module RjuiTools
              module React
                module Converters
                  module Extensions
                    CONVERTER_MAPPINGS = {
                      '#{@name}' => '#{@class_name}',
                    }.freeze
                  end
                end
              end
            end
          RUBY

          File.write(mappings_file, content)
          @logger.info "Created converter_mappings.rb"
        end

        def converter_template
          attr_lines = generate_attribute_lines
          props_lines = generate_props_lines
          is_container = @options[:is_container]

          template = []
          template << '# frozen_string_literal: true'
          template << ''
          template << "# Generated by: #{@command_line}" if @command_line
          template << ''
          template << "require_relative '../base_converter'"
          template << ''
          template << 'module RjuiTools'
          template << '  module React'
          template << '    module Converters'
          template << '      module Extensions'
          template << "        class #{@class_name} < BaseConverter"
          template << '          def convert(indent = 2)'
          template << '            class_name = build_class_name'
          template << '            id_attr = extract_id ? %( id="#{extract_id}") : \'\''
          template << ''
          template.concat(attr_lines)
          template << ''
          template << '            # Build the component JSX'
          template << '            props = []'
          template.concat(props_lines)
          template << '            props_str = props.empty? ? \'\' : " #{props.join(\' \')}"'
          template << ''

          # Add container check
          template.concat(generate_container_check_lines)
          template << ''

          # Generate different output based on container mode
          if is_container == false
            # Force non-container mode
            template << '            <<~JSX.chomp'
            template << "              \#{indent_str(indent)}<#{@name}\#{id_attr} className=\"\#{class_name}\"\#{props_str} />"
            template << '            JSX'
          else
            # Container mode (auto-detect or forced)
            template << '            if is_container'
            template << '              children_jsx = convert_children(indent + 2)'
            template << '              <<~JSX.chomp'
            template << "                \#{indent_str(indent)}<#{@name}\#{id_attr} className=\"\#{class_name}\"\#{props_str}>"
            template << '                #{children_jsx}'
            template << "                \#{indent_str(indent)}</#{@name}>"
            template << '              JSX'
            template << '            else'
            template << '              <<~JSX.chomp'
            template << "                \#{indent_str(indent)}<#{@name}\#{id_attr} className=\"\#{class_name}\"\#{props_str} />"
            template << '              JSX'
            template << '            end'
          end

          template << '          end'
          template << ''
          template << '          protected'
          template << ''
          template << '          def build_class_name'
          template << '            # Get base classes from parent (handles margins, padding, etc.)'
          template << '            base_classes = super'
          template << ''
          template << '            # Add component-specific classes'
          template << "            classes = ['flex', 'flex-col']"
          template << '            classes << base_classes unless base_classes.empty?'
          template << ''
          template << "            classes.compact.reject(&:empty?).join(' ')"
          template << '          end'
          template << '        end'
          template << '      end'
          template << '    end'
          template << '  end'
          template << 'end'

          template.join("\n") + "\n"
        end

        def generate_container_check_lines
          case @options[:is_container]
          when true
            [
              '            # Force container mode',
              '            is_container = true'
            ]
          when false
            [
              '            # Force non-container mode',
              '            is_container = false'
            ]
          else
            [
              '            # Auto-detect container based on children or child',
              "            is_container = (json['children'] && !json['children'].empty?) || (json['child'] && !json['child'].empty?)"
            ]
          end
        end

        def generate_attribute_lines
          return ['            # No custom attributes'] if @options[:attributes].empty?

          @options[:attributes].map do |key, _type|
            "            #{key}_value = json['#{key}']"
          end
        end

        def generate_props_lines
          return ['            # No custom props'] if @options[:attributes].empty?

          lines = []
          @options[:attributes].each do |key, type|
            # Generate binding-aware prop handling
            lines << "            if #{key}_value"
            lines << "              if #{key}_value.is_a?(String) && #{key}_value.start_with?('@{') && #{key}_value.end_with?('}')"
            lines << "                # Handle binding - extract property name"
            lines << "                prop_name = #{key}_value[2..-2]"
            lines << "                props << \"#{key}={\#{prop_name}}\""
            lines << "              else"
            case type.downcase
            when 'string'
              lines << "                props << %(#{key}=\"\#{#{key}_value}\")"
            when 'bool', 'boolean'
              lines << "                props << \"#{key}={\#{#{key}_value}}\""
            when 'int', 'integer', 'number', 'double', 'float'
              lines << "                props << \"#{key}={\#{#{key}_value}}\""
            else
              lines << "                props << %(#{key}={\#{#{key}_value.inspect}})"
            end
            lines << "              end"
            lines << "            end"
          end
          lines
        end

        # Generate attribute definition file for validation
        def generate_attribute_definition_file
          # Skip if no attributes
          return if !@options[:attributes] || @options[:attributes].empty?

          # Determine directory path based on project structure
          if File.exist?(File.join(Dir.pwd, 'rjui_tools'))
            attr_defs_dir = File.join(Dir.pwd, 'rjui_tools', 'lib', 'react', 'converters', 'extensions', 'attribute_definitions')
          else
            attr_defs_dir = File.join(Dir.pwd, 'lib', 'react', 'converters', 'extensions', 'attribute_definitions')
          end

          # Create directory if it doesn't exist
          FileUtils.mkdir_p(attr_defs_dir)

          # Build attribute definitions
          attributes = {}
          @options[:attributes].each do |key, type|
            # Remove @ prefix if this is a binding attribute
            actual_key = key.start_with?('@') ? key[1..-1] : key
            attributes[actual_key] = build_attribute_definition(actual_key, type)
          end

          # Build JSON structure
          json_content = {
            @name => attributes
          }

          # Write to file
          file_path = File.join(attr_defs_dir, "#{@name}.json")
          File.write(file_path, JSON.pretty_generate(json_content))

          @logger.info "Created attribute definition file: attribute_definitions/#{@name}.json"
        end

        # Map type string to JSON schema type (supports binding for all types)
        # @param type [String] The type string from options
        # @return [Array, String] JSON schema type(s) - array for binding support
        def map_type_to_json_type(type)
          case type.downcase
          when 'string'
            ['string', 'binding']
          when 'int', 'integer'
            ['number', 'binding']
          when 'double', 'float'
            ['number', 'binding']
          when 'bool', 'boolean'
            ['boolean', 'binding']
          else
            # Custom class types must use binding syntax (@{propertyName})
            'binding'
          end
        end

        def build_attribute_definition(actual_key, type)
          {
            "type" => map_type_to_json_type(type),
            "description" => "#{actual_key} attribute"
          }
        end

        def to_snake_case(string)
          string
            .gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
            .gsub(/([a-z\d])([A-Z])/, '\1_\2')
            .downcase
        end
      end
    end
  end
end
