# frozen_string_literal: true

require 'fileutils'
require_relative '../../core/logger'
require_relative 'react_component_generator'

module RjuiTools
  module React
    module Generators
      class ConverterGenerator
        def initialize(name, options = {}, config = {}, command_line = nil)
          @name = name  # PascalCase name like CodeBlock
          @class_name = "#{name}Converter"
          @options = options
          @config = config
          @command_line = command_line
          @logger = Core::Logger
        end

        def generate
          @logger.info "Generating custom converter: #{@class_name}"

          # Create converter file
          create_converter_file

          # Update mappings file
          update_mappings_file

          # Create React component skeleton
          component_generator = ReactComponentGenerator.new(@name, @options, @config, @command_line)
          component_generator.generate

          @logger.success "Successfully generated converter: #{@class_name}"
          @logger.info "Converter file: #{converter_file_path}"
          @logger.info "Run 'rjui build' to use the new component in your layouts"
        end

        private

        def extensions_dir
          # Check if we're in the project with rjui_tools at root
          if File.exist?(File.join(Dir.pwd, 'rjui_tools'))
            File.join(Dir.pwd, 'rjui_tools', 'lib', 'react', 'converters', 'extensions')
          else
            File.join(Dir.pwd, 'lib', 'react', 'converters', 'extensions')
          end
        end

        def converter_file_path
          snake_case_name = to_snake_case(@name)
          File.join(extensions_dir, "#{snake_case_name}_converter.rb")
        end

        def create_converter_file
          FileUtils.mkdir_p(extensions_dir)

          file_path = converter_file_path

          if File.exist?(file_path)
            @logger.warn "Converter file already exists: #{file_path}"
            print "Overwrite? (y/n): "
            response = $stdin.gets.chomp.downcase
            return unless response == 'y'
          end

          File.write(file_path, converter_template)
          @logger.info "Created converter file: #{file_path}"
        end

        def update_mappings_file
          mappings_file = File.join(extensions_dir, 'converter_mappings.rb')

          if !File.exist?(mappings_file)
            create_initial_mappings_file(mappings_file)
            return
          end

          content = File.read(mappings_file)

          # Check if mapping already exists
          if content.include?("'#{@name}' =>")
            @logger.warn "Mapping for '#{@name}' already exists in converter_mappings.rb"
            return
          end

          # Add new mapping
          new_mapping = "          '#{@name}' => '#{@class_name}',"

          # Insert the new mapping before the closing brace
          content.sub!(/(CONVERTER_MAPPINGS = \{.*?)(,?)(\s*)(        \}\.freeze)/m) do
            existing = $1
            closing = $4

            if existing =~ /=>/
              "#{existing},\n#{new_mapping}\n#{closing}"
            else
              "#{existing}\n#{new_mapping}\n#{closing}"
            end
          end

          File.write(mappings_file, content)
          @logger.info "Updated converter_mappings.rb"
        end

        def create_initial_mappings_file(mappings_file)
          FileUtils.mkdir_p(File.dirname(mappings_file))

          content = <<~RUBY
            # frozen_string_literal: true

            # This file maps custom component types to their converter classes
            # Auto-generated by rjui g converter command

            module RjuiTools
              module React
                module Converters
                  module Extensions
                    CONVERTER_MAPPINGS = {
                      '#{@name}' => '#{@class_name}',
                    }.freeze
                  end
                end
              end
            end
          RUBY

          File.write(mappings_file, content)
          @logger.info "Created converter_mappings.rb"
        end

        def converter_template
          attr_lines = generate_attribute_lines
          props_lines = generate_props_lines
          is_container = @options[:is_container]

          template = []
          template << '# frozen_string_literal: true'
          template << ''
          template << "# Generated by: #{@command_line}" if @command_line
          template << ''
          template << "require_relative '../base_converter'"
          template << ''
          template << 'module RjuiTools'
          template << '  module React'
          template << '    module Converters'
          template << '      module Extensions'
          template << "        class #{@class_name} < BaseConverter"
          template << '          def convert(indent = 2)'
          template << '            class_name = build_class_name'
          template << '            id_attr = extract_id ? %( id="#{extract_id}") : \'\''
          template << ''
          template.concat(attr_lines)
          template << ''
          template << '            # Build the component JSX'
          template << '            props = []'
          template.concat(props_lines)
          template << '            props_str = props.empty? ? \'\' : " #{props.join(\' \')}"'
          template << ''

          # Add container check
          template.concat(generate_container_check_lines)
          template << ''

          # Generate different output based on container mode
          if is_container == false
            # Force non-container mode
            template << '            <<~JSX.chomp'
            template << "              \#{indent_str(indent)}<#{@name}\#{id_attr} className=\"\#{class_name}\"\#{props_str} />"
            template << '            JSX'
          else
            # Container mode (auto-detect or forced)
            template << '            if is_container'
            template << '              children_jsx = convert_children(indent + 2)'
            template << '              <<~JSX.chomp'
            template << "                \#{indent_str(indent)}<#{@name}\#{id_attr} className=\"\#{class_name}\"\#{props_str}>"
            template << '                #{children_jsx}'
            template << "                \#{indent_str(indent)}</#{@name}>"
            template << '              JSX'
            template << '            else'
            template << '              <<~JSX.chomp'
            template << "                \#{indent_str(indent)}<#{@name}\#{id_attr} className=\"\#{class_name}\"\#{props_str} />"
            template << '              JSX'
            template << '            end'
          end

          template << '          end'
          template << ''
          template << '          protected'
          template << ''
          template << '          def build_class_name'
          template << "            classes = ['flex', 'flex-col']"
          template << ''
          template << "            classes << TailwindMapper.map_width(json['width']) if json['width']"
          template << "            classes << TailwindMapper.map_flex_grow(json['weight']) if json['weight']"
          template << ''
          template << "            classes.compact.reject(&:empty?).join(' ')"
          template << '          end'
          template << '        end'
          template << '      end'
          template << '    end'
          template << '  end'
          template << 'end'

          template.join("\n") + "\n"
        end

        def generate_container_check_lines
          case @options[:is_container]
          when true
            [
              '            # Force container mode',
              '            is_container = true'
            ]
          when false
            [
              '            # Force non-container mode',
              '            is_container = false'
            ]
          else
            [
              '            # Auto-detect container based on children or child',
              "            is_container = (json['children'] && !json['children'].empty?) || (json['child'] && !json['child'].empty?)"
            ]
          end
        end

        def generate_attribute_lines
          return ['            # No custom attributes'] if @options[:attributes].empty?

          @options[:attributes].map do |key, _type|
            "            #{key}_value = json['#{key}']"
          end
        end

        def generate_props_lines
          return ['            # No custom props'] if @options[:attributes].empty?

          @options[:attributes].map do |key, type|
            case type.downcase
            when 'string'
              "            props << %(#{key}=\"\#{#{key}_value}\") if #{key}_value"
            when 'bool', 'boolean'
              "            props << \"#{key}={\#{#{key}_value}}\" unless #{key}_value.nil?"
            when 'int', 'integer', 'number', 'double', 'float'
              "            props << \"#{key}={\#{#{key}_value}}\" if #{key}_value"
            else
              "            props << %(#{key}={\#{#{key}_value.inspect}}) if #{key}_value"
            end
          end
        end

        def to_snake_case(string)
          string
            .gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
            .gsub(/([a-z\d])([A-Z])/, '\1_\2')
            .downcase
        end
      end
    end
  end
end
